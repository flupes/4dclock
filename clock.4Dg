#platform "Gen4-uLCD-32DT"

#inherit "4DGL_16bitColours.fnc"

#inherit "VisualConst.inc"

#inherit "ledDigitsDisplay-ve.inc"
#inherit "PrintDisk.inc"

#inherit "clockConst.inc"

#inherit "DS3224.inc"

#constant ENCODER_CHA_A_PIN PA4
#constant ENCODER_CHA_B_PIN PA5
#constant ENCODER_PUSH_PIN PA6

var g_hours := 0;
var g_minutes := 0;
var g_seconds := 0;
var g_update_h := 1;
var g_update_m := 1;
var g_update_s := 1;

func TickSeconds()
    g_seconds++;
    g_update_s := 1;
    if ( g_seconds > 59 )
        g_seconds := 0;
        g_minutes++;
        g_update_m := 1;
    endif
    if ( g_minutes > 59 )
        g_minutes := 0;
        g_hours++;
        g_update_h := 1;
    endif
    if ( g_hours > 23 )
        g_hours := 0;
    endif
    sys_SetTimer(TIMER1, 100);
endfunc

func ConfigurePins()
    pin_Set(PIN_INP_HI, ENCODER_CHA_A_PIN);
    pin_Set(PIN_INP_HI, ENCODER_CHA_B_PIN);
    pin_Set(PIN_INP_HI, ENCODER_PUSH_PIN);
    Qencoder1(ENCODER_CHA_A_PIN, ENCODER_CHA_B_PIN, 0);
endfunc

func CheckButton(var buttonPin)
    var private pressed_count[2] := [0, 0];
    var private pressed_state[2] := [0, 0];
    var index := 0;
    var pressed := 0;
    if ( buttonPin != ENCODER_PUSH_PIN )
        index := 1;
    endif
    if ( pin_Read(buttonPin) == 0 )
        pressed_count[index]++;
    else
        if ( pressed_count[index] > 1 )
            pressed_count[index]--;
        else
            pressed_state[index] := 0;
        endif
    endif
    if (pressed_state[index] == 0 && pressed_count[index] > 6)
        pressed_state[index] := 1;
        pressed := 1;
    endif
    return (pressed);
endfunc

func main()

    ConfigurePins();

    gfx_Set(SCREEN_MODE,LANDSCAPE) ;

    if (!(file_Mount()))
        while(!(file_Mount()))
            putstr("Drive not mounted...");
            pause(2000);
            gfx_Cls();
            pause(200);
        wend
    endif

    var hstrings ; // Handle to access uSD strings, uncomment if required
    var hFont1 ;   // Handle to access uSD font for year
    var hFont2 ;   // Handle to access uSD font for month
    var hFont3 ;   // Handle to access uSD font for date
    var hFont4 ;   // Handle to access uSD font for day

    hFont1 := file_LoadImageControl("clock.d01", "clock.g01", 1);
    hFont2 := file_LoadImageControl("clock.d02", "clock.g02", 1);
    hFont3 := file_LoadImageControl("clock.d03", "clock.g03", 1);
    hFont4 := file_LoadImageControl("clock.d04", "clock.g04", 1);
    hstrings := file_Open("clock.txf", 'r') ; // Open handle to access uSD strings

    hndl := file_LoadImageControl("clock.dat", "clock.gci", 1);
    // putstr("image loaded properly...");
    // pause(2000);

    gfx_CircleFilled(160, 72, 8, GRAY) ;
    gfx_CircleFilled(160, 108, 8, GRAY) ;

    // year 1.1 generated 04/02/2020 22:24:45
    txt_FontID(hFont1) ; // Font index correct at time of code generation
    txt_FGcolour(WHITE) ;
    txt_BGcolour(BLACK) ;
    gfx_MoveTo(4 , 0) ;
    PrintDisk(hstrings, yearStartH, yearStartL, yearSize, 1) ; // where i is Message 0 - yearCount-1


    // month 1.1 generated 04/02/2020 22:25:00
    txt_FontID(hFont2) ; // Font index correct at time of code generation
    txt_FGcolour(WHITE) ;
    txt_BGcolour(BLACK) ;
    gfx_MoveTo(84 , 0) ;
    PrintDisk(hstrings, monthStartH, monthStartL, monthSize, 9) ; // where i is Message 0 - monthCount-1


    // date 1.1 generated 04/02/2020 22:26:08
    txt_FontID(hFont3) ; // Font index correct at time of code generation
    txt_FGcolour(WHITE) ;
    txt_BGcolour(BLACK) ;
    gfx_MoveTo(180 , 0) ;
    PrintDisk(hstrings, dateStartH, dateStartL, dateSize, 3) ; // where i is Message 0 - dateCount-1

    // day 1.1 generated 04/02/2020 22:26:14
    txt_FontID(hFont4) ; // Font index correct at time of code generation
    txt_FGcolour(WHITE) ;
    txt_BGcolour(BLACK) ;
    gfx_MoveTo(256 , 0) ;
    PrintDisk(hstrings, dayStartH, dayStartL, daySize, 4) ; // where i is Message 0 - dayCount-1

    touch_Set(TOUCH_ENABLE);
    var brightness := 8;
    var x, y, pressed;
    var qenc_delta := 0;
    var counter := 120;
    ledDigitsDisplay(counter/4, iiseconds, 124, 2, 1, 36, 0);

    gfx_Contrast(brightness);
    sys_SetTimerEvent(TIMER1, TickSeconds);
    TickSeconds();
    Qencoder1Reset();

    repeat
        if (g_update_h)
            ledDigitsDisplay(g_hours, iihours, 5, 2, 1, 72, 1) ;
            g_update_h := 0;
        endif
        if (g_update_m)
            ledDigitsDisplay(g_minutes, iiminutes, 173, 2, 1, 72, 0) ;
            g_update_m := 0;
        endif
        if (0 && g_update_s)
            ledDigitsDisplay(g_seconds, iiseconds, 124, 2, 1, 36, 0) ;
            g_update_s := 0;
        endif
        pressed := CheckButton(ENCODER_PUSH_PIN);
        if ( pressed )
            counter := 0;
            ledDigitsDisplay(counter/4, iiseconds, 124, 2, 1, 36, 0);
        endif
        qenc_delta :=  peekW(QEN1_DELTA);
        // quadrature encoder adds 4 ticks for one step: total value/4 is what we want at the end
        if ( qenc_delta != 0 )
            //txt_FontID(FONT_5);
            //putstrXY(8, 160, "     ");
            //putstrXY(8, 180, "     ");
            //putnumXY(8, 160, DEC, counter);
            //putnumXY(8, 180, DEC, qenc_delta);
            counter += qenc_delta;
            if (counter > 240)
                counter -= 240;
            endif
            if (counter < 0)
                counter += 240;
            endif
            ledDigitsDisplay(counter/4, iiseconds, 124, 2, 1, 36, 0);
        endif

        if (touch_Get(TOUCH_STATUS) == TOUCH_RELEASED)
            x := touch_Get(TOUCH_GETX);
            y := touch_Get(TOUCH_GETY);
            if ( y > 120 & y < 220 )
                if ( x < 100 )
                    brightness -= 2;
                    if ( brightness < 2 )
                        brightness := 2;
                    endif
                endif
                if ( x > 220 )
                    brightness += 2;
                    if ( brightness > 14 )
                        brightness := 14;
                    endif
                endif
                gfx_Contrast(brightness);
            endif
        endif
    forever

endfunc

